# 用费曼学习法彻底搞懂 CI/CD：以本项目为例

> **费曼技巧核心 (The Feynman Technique)：**
> 如果你不能简单直白地向一个 12 岁的小孩解释清楚一个概念，那就说明你自己还没真正懂。
>
> 核心步骤：
> 1. **选择概念**。
> 2. **尝试教给别人**（用大白话，去术语化）。
> 3. **发现卡点**（哪里讲不清楚了？）。
> 4. **回归原始资料并简化**（查漏补缺，用类比优化）。

本文将把你刚刚经历的复杂的 GitHub Actions 修复过程，翻译成“人话”。

---

## 第一步：尝试教学——什么是 CI/CD？

**想象我们在开一家乐高工厂（软件项目）。**

以前，我们是几个人在一个房间里拼乐高。
*   你拼飞机的翅膀（前端 Storefront）。
*   我拼飞机的引擎（后端 Medusa）。
*   拼完以后，我们手动把它们凑在一起。经常发现：哎呀，接口对不上！或者你的翅膀太重，把我的引擎压垮了。这就是**集成地狱**。

### 1. CI (Continuous Integration) = 自动质检员
为了不打架，我们在工厂门口请了一个**极其死板的机器人**（GitHub Actions）。

*   **规则：** 任何人想把自己的乐高组件放到公共的大桌子（`main` 分支）上之前，必须先交给机器人。
*   **机器人做什么？**
    *   **Lint (格式检查)：** 它会拿尺子量，看你的积木是不是歪了，颜色对不对。（*刚才报错的 ESLint 就是这一步，机器人说：“你用的尺子型号旧了，我不认！”*）
    *   **Test (测试)：** 它会把你的组件通电运行一下，看会不会爆炸。（*刚才的 `config.test.ts` 报错，就是机器人说：“说明书里有个词我看不懂 [fail is not defined]”。*）
    *   **Build (构建)：** 它试着把你的一堆散乱积木拼成一个完整的模块。如果拼不起来，直接退货。

**只有机器人亮绿灯，你的代码才能进仓库。这就是 CI。**

### 2. CD (Continuous Delivery/Deployment) = 自动快递员
一旦机器人说“质检通过”，另一个机器人就会接手。

*   **Preview (预览)：** 它先把你的飞机放到一个临时的展示柜里（Vercel Preview），发个链接给你：“老板，看看这是你要的效果吗？”
*   **Production (生产)：** 如果你也满意，机器人直接把飞机打包，发货给全世界的客户（上线到生产环境）。

---

## 第二步：回顾卡点——刚才为什么会翻车？

刚才你在推代码时，机器人（CI）红灯报警了，为什么？让我们用“费曼视角”拆解刚才的三个问题：

### 卡点 1：环境变量缺失 (`NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY`)
*   **大白话解释：**
    机器人（CI 服务器）是一个**刚出厂的、脑子一片空白**的新员工。
    你（开发者）的电脑里有一本私密笔记（`.env`），上面写着“仓库大门的密码是 123456”。
    你让机器人去检查大门（运行 `next lint`），但忘了把密码告诉它。
    机器人走到门口，因为没有密码，进不去，所以报错了。
*   **深刻理解原则：** **CI 环境是“无状态”且“甚至无知”的。** 它不知道任何你没显式告诉它的东西。必须在 `.github/workflows/ci.yml` 里把密码（环境变量）写在纸条上递给它。

### 卡点 2：ESLint 配置冲突 (`Invalid option --ext`)
*   **大白话解释：**
    你给机器人下达指令：“用 `eslint` 工具检查代码，记得用 `--ext` 这个旧方法。”
    但是机器人的工具箱刚刚升级了（升级到了 ESLint 9）。
    新工具说：“我现在很智能，不需要你告诉我检查什么后缀的文件（`--ext`），我自己知道。你非要告诉我，我反而听不懂了。”
    所以机器人罢工了。
*   **深刻理解原则：** **工具链的演进性。** CI/CD 里的工具（Node.js, pnpm, ESLint）都在不断更新。维护 CI 就是要不断协调这些工具之间的“代沟”。

### 卡点 3：测试里的 `fail is not defined`
*   **大白话解释：**
    你在测试代码里写了一句：“如果出问题了，就大喊一声‘失败’（fail）！”
    但是你忘了教机器人什么是“大喊”。在它的字典里，没有 `fail` 这个词。
    所以我们要改成通用的语言：“如果出问题了，就**扔出一个错误**（throw Error）！”这个动作全宇宙的机器人都能听懂。
*   **深刻理解原则：** **标准化的重要性。** 尽量使用语言原生支持的标准（如 `throw Error`），而不是依赖特定环境才有的方言（如 Jest 的 `fail`），这样能让你的代码更健壮，在哪都能跑。

---

## 第三步：简化与内化——CI/CD 的三大铁律

通过本项目，我们可以总结出 CI/CD 必须遵守的三条铁律：

1.  **自动化原则 (Automation)：**
    **凡是需要人脑记的，最后都会忘。**
    *   不要指望开发者记得“先运行 Lint 再提交”。
    *   必须把这个步骤写进 `ci.yml`，强制机器人去执行。

2.  **环境隔离原则 (Isolation)：**
    **“在我电脑上能跑”是软件工程最大的谎言。**
    *   CI 的价值就在于它提供了一个**干净的、什么都没有的**环境。
    *   如果在 CI 上能跑，说明你的代码是真的没问题；如果只能在你电脑上跑，说明你的代码依赖了你本地的“私货”。

3.  **反馈即时性 (Fast Feedback)：**
    **报错越早越好。**
    *   CI 就像是拼写检查。你刚写错一个词，它就划红线。
    *   如果没有 CI，你要等到客户收到货（上线）发现飞机飞不起来，那时候修复的代价就是现在的 100 倍。

---

## 总结

你也看到了，所谓的 CI/CD 专家，其实就是更擅长**和机器人沟通**的人。
*   你知道机器人很笨（不知道环境变量）。
*   你知道机器人很死板（指令必须精确）。
*   你知道机器人很诚实（有一点错就不让过）。

当你能从机器人的角度思考问题时，你也就掌握了 CI/CD。
