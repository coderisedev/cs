# 用费曼学习法彻底搞懂 Next.js：以本项目为例

> **费曼技巧核心 (The Feynman Technique)：**
> 1. **选择概念**。
> 2. **尝试教给别人**（用大白话，去术语化）。
> 3. **发现卡点**（哪里讲不清楚了？）。
> 4. **回归原始资料并简化**。

本文将把你正在用的 Next.js 框架，翻译成一家“智能餐厅”的运作模式。

---

## 第一步：尝试教学——什么是 Next.js？

**想象我们在经营一家高级餐厅（网站）。**

### 1. React vs Next.js
*   **React 是厨师。** 他只负责做菜（画 UI，生成按钮、输入框）。
*   **Next.js 是餐厅经理。** 他不直接做菜，但他负责：
    *   **带位（Routing）：** 决定客人坐哪（访问哪个 URL）。
    *   **预制菜（SSR/SSG）：** 提前让厨师把菜备好，客人一来直接上菜，不用等。
    *   **传菜（Data Fetching）：** 把厨房（服务器/数据库）里的原料拿给厨师。

**如果只有 React（传统 SPA）：**
客人进店，桌子上是空的（白屏）。客人要坐下等很久，厨师才现去买菜、现切、现炒。体验很差，而且如果有美食评论家（搜索引擎爬虫）来，看到空桌子就走了，觉得你家没吃的。

**有了 Next.js：**
客人进店，桌子上已经摆好了凉菜和主食（HTML 预渲染）。客人马上就能吃。

---

## 第二步：核心概念——厨房（Server）与餐桌（Client）

Next.js 13+ (App Router) 最难懂的就是 Server Components 和 Client Components。我们用餐厅的比喻来彻底厘清。

### 1. Server Components (服务端组件) = 后厨大师傅
*   **位置：** 待在封闭的后厨（服务器）。
*   **特权：** 直接开冰箱拿肉（直接连数据库/API），甚至可以看到老板的保险柜（API Key）。
*   **限制：** **绝对不能见客人。** 他听不到客人说“加点盐”（不能处理 `onClick`），也不记得客人的名字（不能用 `useState`）。
*   **工作模式：** 把菜做好，通过传菜窗口递出去。
*   **项目案例：** 你的 `src/app/[countryCode]/page.tsx`。
    *   它在后厨直接从 Medusa 拿商品数据，把 HTML 拼好，发给浏览器。

### 2. Client Components (客户端组件) = 餐厅服务员
*   **位置：** 待在用餐区（浏览器）。
*   **特权：** 可以跟客人说话（响应点击），可以拿小本本记客人的要求（`useState`），可以使用餐桌上的调料瓶（浏览器 API，如 `window`, `localStorage`）。
*   **限制：** **进不去后厨。** 不能直接拿生肉（数据库），也不能看保险柜。
*   **标志：** 额头上贴着 `'use client'` 的标签。
*   **项目案例：** 你的 `login-client.tsx`。
    *   因为它要监听用户输入邮箱、点击发送按钮，还要记住“现在是第几步”，所以必须是服务员（Client Component）。

### 3. Server Actions (服务器端操作) = 传菜单
服务员（Client）怎么让后厨（Server）做一道新菜？
*   **以前：** 服务员要打电话（API 请求）给后厨。
*   **Next.js Server Actions：** 服务员直接把一张单子（函数调用）递进窗口。
*   **项目案例：** `src/lib/actions/auth.ts` 里的 `initiateOTPLoginAction`。
    *   你在前端组件里直接调用这个函数，就像调用本地函数一样。但实际上，Next.js 帮你把这个请求像变魔术一样传到了后厨去执行，然后把结果还给你。

---

## 第三步：理解原则——为什么有这些规矩？

### 为什么默认全是 Server Components（后厨）？
*   **原则：少运东西。**
    *   如果所有厨师都跑到客人的餐桌旁做菜（传统 React），那得把锅碗瓢盆（巨大的 JS 包）都搬到餐桌上。
    *   让厨师在后厨做好，只把**成品菜（HTML）**端上来，餐桌就宽敞了，加载就快了。

### 为什么文件夹名字要有中括号 `[countryCode]`？
*   **原则：约定大于配置 (Convention over Configuration)。**
    *   Next.js 经理说：“别给我写又臭又长的路由配置表。我看文件夹名字就知道怎么带位。”
    *   `[countryCode]` 就像是一个**万能包间**。不管客人是 `US` 来的还是 `CN` 来的，都领进这个房间，只是房间里的装饰（参数）会根据客人的来源自动变化。

### 为什么不能在 Server Component 里用 `onClick`？
*   **大白话：**
    *   因为那个组件是在**服务器**上运行完就消失了的。
    *   当 HTML 送到浏览器给用户看的时候，Server Component 的代码早就下班回家了。用户点屏幕的时候，它根本不在场，怎么响应？

---

## 总结：Next.js 的三大铁律

1.  **能不进浏览器就不进浏览器：** 默认用 Server Components，只有需要互动时才用 Client Components。这样网站最快。
2.  **后厨归后厨，前厅归前厅：** 敏感数据（API Key）永远锁在后厨（Server），不要带到前厅（Client）。
3.  **文件即地图：** 看着文件夹结构，就知道网站的 URL 长什么样。

当你写代码时，脑子里要有这幅图：**我在后厨切菜（Server），还是在前厅端盘子（Client）？还是在窗口递单子（Server Actions）？** 分清楚位置，就不会报错了。
